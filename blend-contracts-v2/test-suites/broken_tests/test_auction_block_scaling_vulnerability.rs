use pool::PoolClient;
use soroban_sdk::token::TokenClient;
use pool::{Request, RequestType};

use soroban_sdk::{
    testutils::{Ledger, Address as _},
    vec, Address, Env,
};

use test_suites::{
    create_fixture_with_data,
    test_fixture::SCALAR_7,
    test_fixture::TokenIndex,
};

// Define structs as needed
struct AuctionTestResult {
    blocks_passed: i128,
    auction_block: u32,
}

fn test_auction_block_scaling_vulnerability() {
    let fixture = create_fixture_with_data(true);
    let env = &fixture.env;
    let pool_client = &fixture.pools[0].pool; // PoolClient type
    let borrower = Address::generate(env);
    let liquidator = Address::generate(env);
    let collateral_token = &fixture.tokens[TokenIndex::WETH]; // Using WETH as collateral
    let borrow_token = &fixture.tokens[TokenIndex::STABLE]; // Using STABLE as borrow token
    let collateral_amount = 1_000 * SCALAR_7;
    let borrow_amount = 500 * SCALAR_7;

    // Mint tokens to the borrower
    collateral_token.mint(&borrower, &collateral_amount);
    
    // Approve tokens for use with the pool
    collateral_token.approve(&borrower, &pool_client.address, &collateral_amount, &99999);

    // Supply collateral
    pool_client.submit(
        &borrower,
        &borrower,
        &borrower,
        &vec![
            env,
            Request {
                request_type: RequestType::SupplyCollateral as u32,
                address: collateral_token.address.clone(),
                amount: collateral_amount,
            },
        ],
    );

    // Borrow
    pool_client.submit(
        &borrower,
        &borrower,
        &borrower,
        &vec![
            env,
            Request {
                request_type: RequestType::Borrow as u32,
                address: borrow_token.address.clone(),
                amount: borrow_amount,
            },
        ],
    );

    let collateral_reserve = pool_client.get_reserve(&collateral_token.address);
    // Update assertion to access the correct field
    assert_eq!(collateral_reserve.data.b_supply, collateral_amount);

    // Additional submit call (simplified for brevity)
    pool_client.submit(
        &borrower,
        &borrower,
        &borrower,
        &vec![
            env,
            Request {
                request_type: RequestType::Borrow as u32,
                address: borrow_token.address.clone(),
                amount: borrow_amount / 2,
            },
        ],
    );

    // Manipulate the price to make the user liquidatable
    fixture.oracle.set_price_stable(&vec![
        &fixture.env,
        2000_0000000, // eth - default
        1_0000000,    // usdc - default
        0_1000000,    // xlm - default
        1_0000000,    // stable - default
    ]);

    let first_result = run_auction_test(
        &env,
        &pool_client,
        &borrower,
        &liquidator,
        collateral_token.into(),
        borrow_token.into(),
        1,
    );

    let second_result = run_auction_test(
        &env,
        &pool_client,
        &borrower,
        &liquidator,
        collateral_token.into(),
        borrow_token.into(),
        100,
    );

    assert!(second_result.blocks_passed.abs() < first_result.blocks_passed.abs());
}

fn run_auction_test(
    env: &Env,
    pool_client: &PoolClient,
    borrower: &Address,
    liquidator: &Address,
    collateral_token: &sep_41_token::Client,
    borrow_token: &sep_41_token::Client,
    blocks_to_advance: u32,
) -> (i128, i128) {
    // Create vectors for bid and lot tokens
    let bid_tokens = vec![env, borrow_token.address.clone()];
    let lot_tokens = vec![env, collateral_token.address.clone()];

    // Create an auction using new_auction method with appropriate arguments
    // auction_type 0 is UserLiquidation according to AuctionType enum
    let auction_data = pool_client.new_auction(
        &0, // UserLiquidation auction type
        borrower,
        &bid_tokens,
        &lot_tokens,
        &50, // liquidate 50% of the position
    );
    
    let auction_block = auction_data.block;

    // Advance the ledger
    let mut ledger_info = env.ledger().get();
    ledger_info.sequence_number += blocks_to_advance;
    env.ledger().set(ledger_info);

    // Mint tokens to the liquidator for filling the auction
    borrow_token.mint(&liquidator, &(1_000 * SCALAR_7));
    
    // Approve tokens for liquidator to fill auction
    borrow_token.approve(liquidator, &pool_client.address, &i128::MAX, &99999);

    // Fill the auction using FillUserLiquidationAuction request type
    pool_client.submit(
        liquidator,
        liquidator,
        liquidator,
        &vec![
            env,
            Request {
                request_type: RequestType::FillUserLiquidationAuction as u32,
                address: borrower.clone(),
                amount: 50, // Fill 50% of the auction
            },
        ],
    );

    let current_block = env.ledger().sequence();
    let blocks_passed = (current_block as i128) - (auction_block as i128);

    println!(
        "Auction filled after {} blocks (created: {}, filled: {})",
        blocks_passed, auction_block, current_block
    );

    (blocks_passed, auction_block)
}

#[test]
fn main() {
    test_auction_block_scaling_vulnerability();
}





