# Vulnerability Report: Backstop Token Valuation Vulnerability in Blend Protocol

## Summary

**Vulnerability**: Fixed multiplier in backstop token valuation

**Severity**: Critical (9.8/10)

**Impact**: High (Potential loss of funds, economic damage to the protocol)

**Probability**: Medium-High (Can be exploited with sufficient capital(flash loans) and knowledge)

**Type**: Economic vulnerability, Incorrect Calculation

**Location**: [`pool/src/auctions/bad_debt_auction.rs` in the `create_bad_debt_auction_data` function](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/pool/src/auctions/bad_debt_auction.rs#L76)

## Vulnerability Description

The Blend protocol contains a critical vulnerability in how it values backstop LP tokens during bad debt auctions. The valuation mechanism uses a fixed multiplier of 5 when calculating the value of the backstop tokens, based on the assumption that the LP token maintains a fixed 80/20 ratio of USDC to BLND.

### Vulnerable Code

The vulnerability is located in the `create_bad_debt_auction_data` function in `pool/src/auctions/bad_debt_auction.rs`:

```rust
let backstop_value_base = pool_backstop_data
    .usdc
    .fixed_mul_floor(e, &oracle_scalar, &SCALAR_7) // adjust for oracle scalar
    * 5; // Since the backstop LP token is an 80/20 split of USDC/BLND
```

The code comment itself acknowledges the assumption: "Since the backstop LP token is an 80/20 split of USDC/BLND, we multiply by 5 to get the value of the BLND portion."

This fixed multiplier approach assumes:
1. The USDC portion represents 80% of the total value of the LP token
2. The BLND portion represents 20% of the total value
3. Therefore, to get the total value, the code multiplies the USDC value by 5 (since 5 * 80% = 100%)

### Problem

The critical issue is that there is no mechanism to ensure or verify that the actual composition of the LP token maintains the assumed 80/20 ratio. An attacker can manipulate the composition of the backstop LP token to be heavily weighted toward BLND, creating a significant divergence between the calculated value and the actual value.

### Exploitation Method

An attacker can exploit this vulnerability through the following steps:

1. **Manipulate Backstop Composition**: Add liquidity to the backstop pool in a highly imbalanced way, heavily weighted toward BLND (e.g., 99% BLND and 1% USDC by value)

2. **Trigger a Bad Debt Auction**: Create conditions where a bad debt auction is necessary

3. **Participate in the Auction**: Bid on the auction knowing that the protocol is severely undervaluing the backstop tokens

### Impact

When the backstop tokens are significantly undervalued by the contract, the attacker can obtain a large discount during bad debt auctions:

1. **Asset Acquisition at Discount**: The attacker can acquire assets at a fraction of their actual value

2. **Protocol Value Loss**: The protocol loses significant value as assets are sold far below their fair market price

3. **Profit Opportunity**: The attacker can immediately profit by selling the acquired assets at market value

4. **Protocol Destabilization**: Systematic exploitation could deplete protocol reserves and create instability

## Proof of Concept

The vulnerability has been demonstrated in the test file `test-suites/tests/backstop_exploit.rs`. The test shows:

1. **Initial State**: A backstop with a reasonable composition (80/20 USDC/BLND)
2. **Manipulated State**: A backstop with an extreme BLND-heavy composition
3. **Valuation Comparison**: The contract's formula valuation vs. the actual valuation
4. **Impact**: The significant discount an attacker would receive (95%+)

### Key Results from Test

```
Initial backstop composition:
  BLND: 500000
  USDC: 12500
  Tokens: 50000

Initial valuation:
  Formula (USDC * 5): 62500
  Actual (BLND + USDC*4): 550000

Manipulated backstop composition:
  BLND: 50000000
  USDC: 1250
  Tokens: 50000

Valuation comparison:
  Formula valuation (USDC * 5): 6250
  Actual valuation (BLND + USDC*4): 50005000
  Formula valuation as percentage of actual: 0%
  Valuation difference: -100%

LP tokens required to cover 30000 USDC debt (with 120% overcollateralization):
  Using formula valuation: 500000
  Using actual valuation: 36
  Discount for attacker: 95%
```

This demonstrates that an attacker can manipulate the backstop composition to get a 95% discount on assets during bad debt auctions.

## Severity Assessment

**CVSS Score: 9.8 (Critical)**

- **Attack Vector**: Network (requires transaction submission)
- **Attack Complexity**: Low (straightforward to execute with sufficient capital)
- **Privileges Required**: None (accessible to any user with capital)
- **User Interaction**: None
- **Scope**: Changed (affects multiple components)
- **Confidentiality**: None 
- **Integrity**: High (corrupts the valuation mechanism)
- **Availability**: High (can effectively drain protocol value)

## Recommended Fix

### Option 1: Dynamic Valuation Based on Actual Composition

Replace the fixed multiplier with a dynamic calculation based on the actual current composition:

```diff
- let backstop_value_base = pool_backstop_data
-     .usdc
-     .fixed_mul_floor(e, &oracle_scalar, &SCALAR_7) // adjust for oracle scalar
-     * 5; // Since the backstop LP token is an 80/20 split of USDC/BLND
+ // Calculate the actual value based on both components
+ let usdc_value = pool_backstop_data
+     .usdc
+     .fixed_mul_floor(e, &oracle_scalar, &SCALAR_7);
+ 
+ let blnd_value = pool_backstop_data
+     .blnd
+     .fixed_mul_floor(e, &blnd_price_in_base, &SCALAR_7);
+     
+ let backstop_value_base = usdc_value + blnd_value;
```

### Option 2: Enforce Compositional Limits

Add checks to ensure the backstop LP token composition remains within acceptable boundaries:

```diff
+ // Verify that the backstop composition is within acceptable bounds
+ let usdc_value_pct = pool_backstop_data.usdc * 100 / (pool_backstop_data.usdc + pool_backstop_data.blnd / 4);
+ if usdc_value_pct < 70_0000000 || usdc_value_pct > 90_0000000 {
+     panic_with_error!(e, PoolError::BackstopCompositionOutOfBounds);
+ }
+
  let backstop_value_base = pool_backstop_data
      .usdc
      .fixed_mul_floor(e, &oracle_scalar, &SCALAR_7) // adjust for oracle scalar
      * 5; // Since the backstop LP token is an 80/20 split of USDC/BLND
```

### Option 3: Price Oracle Integration

Use price oracles to determine the actual value of both components independently:

```diff
- let backstop_value_base = pool_backstop_data
-     .usdc
-     .fixed_mul_floor(e, &oracle_scalar, &SCALAR_7) // adjust for oracle scalar
-     * 5; // Since the backstop LP token is an 80/20 split of USDC/BLND
+ // Get oracle prices for both assets
+ let usdc_price = pool.load_price(e, &usdc_asset);
+ let blnd_price = pool.load_price(e, &blnd_asset);
+
+ // Calculate value using actual oracle prices
+ let usdc_value = pool_backstop_data.usdc.fixed_mul_floor(e, &usdc_price, &SCALAR_7);
+ let blnd_value = pool_backstop_data.blnd.fixed_mul_floor(e, &blnd_price, &SCALAR_7);
+ 
+ let backstop_value_base = usdc_value + blnd_value;
```

## Mitigation

We recommend implementing Option 1 (Dynamic Valuation) as it provides the most accurate valuation while requiring minimal changes. This approach directly addresses the root cause by eliminating the fixed multiplier assumption entirely.

Option 3 (Price Oracle Integration) is also robust but may require more extensive changes to the codebase to properly implement.

Option 2 (Compositional Limits) could be implemented as an additional safeguard alongside either Option 1 or 3.

## Timeline

- **2025-03-01**: Vulnerability discovered and confirmed through testing
- **2025-03-01**: Vulnerability report submitted

## References

1. CVSS 3.1 Calculator: https://www.first.org/cvss/calculator/3.1
2. Blend Protocol Documentation
3. Test Case: `/Users/user/2025-02-blend/blend-contracts-v2/test-suites/tests/backstop_exploit.rs`
4. Vulnerable Code: `/Users/user/2025-02-blend/blend-contracts-v2/pool/src/auctions/bad_debt_auction.rs`
