#![cfg(test)]
use soroban_sdk::Env;
use soroban_fixed_point_math::FixedPoint;
use test_suites::{
    create_fixture_with_data,
    test_fixture::SCALAR_7,
};
use backstop::PoolBackstopData;

// This test demonstrates a vulnerability in the backstop token valuation
// The issue is that the bad debt auction uses a fixed multiplier of 5,
// assuming an 80/20 ratio of USDC/BLND, but this ratio can be manipulated
#[test]
fn test_backstop_token_valuation_vulnerability() {
    // Create a test fixture with standard data
    let fixture = create_fixture_with_data(false);
    let pool_address = &fixture.pools[0].pool.address;
    let backstop_client = &fixture.backstop;
    
    // Get the initial backstop data (expected to have ~80/20 USDC/BLND ratio)
    let initial_backstop_data = backstop_client.pool_data(pool_address);
    
    // Calculate the valuation using the vulnerable formula
    // The vulnerability is in using a fixed multiplier of 5 (in bad_debt_auction.rs)
    let initial_expected_valuation = initial_backstop_data.usdc
        .fixed_mul_floor(SCALAR_7, SCALAR_7)
        .unwrap() * 5; // The vulnerable multiplier
    
    // Calculate the actual value (BLND + 4*USDC, assuming USDC = 4*BLND in value)
    let initial_actual_valuation = initial_backstop_data.blnd + initial_backstop_data.usdc * 4;
    
    println!("Initial backstop composition:");
    println!("  BLND: {}", initial_backstop_data.blnd / SCALAR_7);
    println!("  USDC: {}", initial_backstop_data.usdc / SCALAR_7);
    println!("  Tokens: {}", initial_backstop_data.tokens / SCALAR_7);
    println!("  Q4W %: {}", initial_backstop_data.q4w_pct / SCALAR_7);
    println!("  Expected valuation using formula (USDC * 5): {}", initial_expected_valuation / SCALAR_7);
    println!("  Actual valuation (BLND + USDC*4): {}", initial_actual_valuation / SCALAR_7);
    
    // Initial difference between formula valuation and actual valuation
    let initial_diff_pct = (initial_expected_valuation - initial_actual_valuation) * 100 / initial_actual_valuation;
    println!("  Initial valuation difference: {}%", initial_diff_pct / SCALAR_7);
    
    // STEP 1: Simulate an attacker manipulating the LP token composition
    
    // In a real-world exploit, an attacker would add imbalanced liquidity to the LP pool
    // We'll simulate this by creating a manipulated backstop data structure
    println!("\nSimulating manipulated backstop state...");
    let manipulated_blnd = initial_backstop_data.blnd * 10; // 10x BLND value
    let manipulated_usdc = initial_backstop_data.usdc / 2;  // 50% USDC value
    
    // Create a simulated manipulated backstop data
    let manipulated_backstop_data = PoolBackstopData {
        tokens: initial_backstop_data.tokens,  // Same number of LP tokens
        q4w_pct: initial_backstop_data.q4w_pct, // Same percentage queued for withdrawal
        blnd: manipulated_blnd,                // Manipulated BLND amount
        usdc: manipulated_usdc,                // Manipulated USDC amount
    };
    
    // Calculate valuation using vulnerable formula (still uses fixed multiplier of 5)
    let manipulated_expected_valuation = manipulated_backstop_data.usdc
        .fixed_mul_floor(SCALAR_7, SCALAR_7)
        .unwrap() * 5;
    
    // Calculate actual valuation based on token values
    let manipulated_actual_valuation = manipulated_backstop_data.blnd + manipulated_backstop_data.usdc * 4;
    
    println!("Manipulated backstop composition:");
    println!("  BLND: {}", manipulated_backstop_data.blnd / SCALAR_7);
    println!("  USDC: {}", manipulated_backstop_data.usdc / SCALAR_7);
    println!("  Expected valuation using formula (USDC * 5): {}", manipulated_expected_valuation / SCALAR_7);
    println!("  Actual valuation (BLND + USDC*4): {}", manipulated_actual_valuation / SCALAR_7);
    
    // Calculate the difference between the valuations (negative means formula undervalues)
    let manipulated_diff_pct = (manipulated_expected_valuation - manipulated_actual_valuation) * 100 / manipulated_actual_valuation;
    println!("  Manipulated valuation difference: {}%", manipulated_diff_pct / SCALAR_7);
    
    // STEP 2: Demonstrate the impact on bad debt auctions
    
    // In a bad debt auction, the backstop's LP tokens are used to cover USDC debt
    // The auction would value LP tokens according to the vulnerable formula
    let usdc_debt = 30_000_0000000; // Example debt amount
    
    // Calculate LP tokens needed according to the vulnerable formula
    let lp_tokens_needed_by_formula = usdc_debt
        .fixed_mul_floor(1_2000000, SCALAR_7) // 120% overcollateralization
        .unwrap()
        .fixed_div_floor(
            manipulated_expected_valuation / manipulated_backstop_data.tokens, 
            SCALAR_7
        ).unwrap();
    
    // Calculate LP tokens needed according to actual value
    let lp_tokens_needed_actual = usdc_debt
        .fixed_mul_floor(1_2000000, SCALAR_7) // 120% overcollateralization
        .unwrap()
        .fixed_div_floor(
            manipulated_actual_valuation / manipulated_backstop_data.tokens, 
            SCALAR_7
        ).unwrap();
    
    // Calculate the discount attacker gets due to the vulnerability
    let discount_percent = (lp_tokens_needed_actual - lp_tokens_needed_by_formula) * 100 / lp_tokens_needed_actual;
    
    println!("\n=== VULNERABILITY EXPLOITATION SUMMARY ===");
    println!("1. The backstop valuation uses a fixed multiplier of 5 (USDC * 5)");
    println!("2. This assumes a fixed 80/20 ratio of USDC/BLND by value in the LP token");
    println!("3. An attacker can manipulate the LP token ratio to be BLND-heavy");
    println!("4. The formula still uses the fixed multiplier despite the changed composition");
    println!("5. Result: After manipulation, backstop token valuation is off by {}%", manipulated_diff_pct / SCALAR_7);
    println!("6. LP tokens needed to cover debt (by formula): {}", lp_tokens_needed_by_formula / SCALAR_7);
    println!("7. LP tokens actually needed for same value: {}", lp_tokens_needed_actual / SCALAR_7);
    println!("8. Discount attacker gets in auction: {}%", discount_percent / SCALAR_7);
    println!("9. Impact: Attacker can participate in bad debt auctions");
    println!("   and acquire assets at a significant discount due to overvalued backstop tokens");
    println!("=============================================");
    
    // Assert that the vulnerability exists and can be exploited
    assert!(manipulated_diff_pct < -50_0000000, "Vulnerability not demonstrated - valuation difference too small");
    assert!(lp_tokens_needed_by_formula < lp_tokens_needed_actual, "Vulnerability not exploitable - no discount available");
    assert!(discount_percent > 20_0000000, "Discount is not significant enough");
}
